2018-10-05
created new project, built up the basic rendering framework including ViewPlane/Camera/Scene/RayTracer and some primary classes(Vec3, Ray, HitRecord) 
(can render very few geometry flat-color shaded objects, like shpere/rectangle/plane)

2018-10-06
tried to fix the hit function bugs among multiply objects and failed.

2018-10-07
riched the geometry objects in library, added triangle, bbox hit functions.

2018-10-08
built up and tested the scene from <<Ray tracing from the ground up>>, figure 9.9(b)
fixed multiply objects hit function bugs.

2018-10-10
tested the movable camera effect in real-time rendering(still by using CDC SetPixel through double buffer on Windows7)
added new virtual function UpdateScene in Scene class to prepare for the camera animation

2018-10-11
added namespace called LaplataRayTracer to each class
added ShadeObject.h and moved the NormalShpere class in. Further will support other objects with a variety of materials.
added/supported log mechanism, just this one.

2018-10-18
added Point3 and Point2 classes to distinguish the vector3 from them.

2018-10-19
removed Point3 and confirmly decided to use Vec3T class to represent Point and Vector both, cause a point is a vector whose origin point is 
located at origin(0,0,0)
changed the CMemBuffer class, added Load and Unload functions to maintain the underline BITMAP handle inside, in this way, we can benifit from being able to remove the HBITMAP outside this class.
added SquareDistance and Distance for both Vec3 and Point2 classes.
added texture class to support the scene background when a ray hit anything in the world.

2018-10-20
changed RayCastTracer directly to WhittedTracer to support recursively trace those reflected rays by the specified maxDepath.
added new gemoetry object, the Disk object
added Random class (adopted drand48() and srand48() transported from unix)
build up a scene to prepare for next step of material shader.

2018-10-23
2018-10-24
added lambertian diffuse material and tested matte-like material by implemented the ambient occlusion
(the first ever shading image produced)
result image is in ./ShowCaseOfScreenShoot/AmbientOcclusion1.png
and also, added metal(perfect reflection) material to material system, output image in ./ShowCaseOfScreenShoot/MetalShading1.jpg

2018-11-04
added rendering process callback function to scene class to notify outside something during the rendering process.
and added rendering process percentage prompt message to the main window title based on the callback function
tried to build up a image texture sub-class, but didn't make it becase still need to smooth the interfaces among varieties of 
texture sub-classes such as const texutre, image texture and so forth, feel a bit messy about it.

2018-11-06
added constant texture class

2018-11-08
changed DirYTexture to SimpleSkyTexture
defined ImageTexutre class (members data and functions) not implement yet.

2018-12-19
changed WhittedTracer to PathTracer
the previous implementation of OrthoCamera was definitely wrong, so I re-wrote it again.
removed MaterialShpere/MaterialRectangle... designation, because it's sub classes are uncountable, instead, we use MaterialObject(GeometryObject *, Material *) to hold a bunch of exisitent Simple Geomerty Objects in addition to a pointer of Material class, in this way we do the re-use through
aggregation/compsition object into MaterialObject. It dramatically reduses the number of material sub classes.
changed the RenderCallback function to IRenderWindowSink interface classes to inhance its cohesion. Rather than just leave some seperated callback
functionss everywhere, we collect those functions to the concrete class of IRenderWindowSink, in this case, it's in RayTraceDemoDlg.cpp.

2018-12-20
changed LambertianMaterial to MatteMaterial, because Lambertian is the feature of BRDF which is the underlying implementation of a certain material object.
added SimpleBox to Geomerty set
added SimpleRing to Geomerty set
built up a very interesting scene including a plane with MatteMertial and a box with the same material in Matte to adjust the envrionment light from dark(like (0.1,0.1,0.1)) to brighter.
Still, I found out that the OrthoCamera was wrong, so I fixed it a bit.
assigned all pointers related to ray tracer to nullptr rather NULL.
 
2018-12-24
changed different parameters to see the scene changes to clear the confustion about the shadow on path tracing.
added xy xz yz reactangle utilities objects in order to build up the Cornell Box's walls, but the flip normal deosn't work

2018-12-25
got a huge success tonight. finshed to setting up the Cornel Box single-handed, which is as the same as the one in <<RTGU>> and <<Next Week>>, thus it proves the accuracy of the pin-hole camera and also paved the way for the next excited thing, a glass ball upon the floor then we will see the caustics produced by the top light transimitting through the ball.
understood the flip normal and how it works, figured out that our previous implementation was right, the reason why you still can see the rect regardless of it's normal's direction, it's because that the bottom rectangle plane is not dark, in the cases of XY rect and YZ rect, it still can absorb the lights from the varities of the directions of the bottom plane, and because the bottom plane was with the constant color, so no matter the normal is (1,0,0) or (-1,0,0) for YZ rect, the color rendered was always the same, and it's same for XY plane. But the XZ plane is a exception.
The real funy thing is because the ambient occlusion which takes place between the XZ plane and the bottom plane is dark, so when its normal is (0, -1, 0) the MatteMaterial's shade function in which it uses the normal returned from HitTest function, the normal will determine the direction which the light should sample to, therefore, if it samples the environment sky, we can see its color then, otherwise, it samples the ambient occlusion, so,
we see its dark color.
and there is another mistake during the debug, that is, if you sample 10X10, then you change the times, everything else related must have to be changed too. Like, you change sample to 16X16, then color /= 100 should be changed to color /= 256. Be careful with that.

2018-12-26
created new class, Light, to represent the encapuslation object of GeometryObject and Texture rather use MateralObject directly, which may not be obvious, in addition to define some functions related to Light such as TurnON/TurnOFF
modified the scene set up yesterday to create a dymanic lightting effect through a timer to control the logic for the three lights in the scene with
a circle from completely dark to one light, then two lights and three lights

2018-12-27
added dielectrics material to RT engine
added a glass ball in the middle of the cornel box with 500x500x50 sampling which took the rendering time about 60 mins
added a mirror upon the back wall

2018-12-28
added two of very primary tone-mapping operators: max_to_one and clamp_to_one, in this way, currently our engine allows us to set up
the light with brighter lighting bigger than 1.0,1.0,1.0, the final image whill handle it, so it looks like HDR

2019-01-01
introduced the IConable interface and let Texture/Material/GeometryObject be cloneable as well as implemented the copy constructor and
assign operator = for relavent classes.
added CompoundObject prepared for implementation of the RegularGrid to tracarge number of objects.
copied ext folder, so far it contains PNG image process files used for texutre mapping later.

2019-01-03
added a new ray tracer, RayCastTracer, prepare for implmentation of RTGU style rendering
completed to implement CompoundObject class, parpare for Regular Grid object
moved the function SetRayTraceEnv to its base class and made the member mEnv object to be protected data member

2019-01-05
changed float to double for all geomerty properties and some material properties, like RefIdx for dielectric and Fuzz for metal, BUT keep
all color3f or pixel related things still be float, most importantly, all Textures are float members; and tested lots of previous scenes to
make sure the intersection and everything is all right.
added BBox class prepared for Regular Grid;
minorly modified the MetalMaterial class to support fuzz feature or as we known it is glossy material, but it's implementation is quite differant
to RTGU;
added Math.h Sampling.h Utility.h and removed some math functions like reflect/refract functions to Math class and before sample_upon_unit_shpere
to Sampling class, and our BBox was placed in Utility class.

2019-01-12
added Length and SqureLength functions to Point2d
added SampleUponUnitDisk samping function
designed the mesh/grid/mesh uv triangle classes blue print

2019-01-13
added MeshObject.h PLYReader.h ResourcePool.h
changed names, math.h to surface.h, BBox to AABB;
added GetBoundingBox interface to all objects on the geomertyobject class tree
 
2019-01-14
implemented the GetBoundingBox interface for all of geomerty objects;
minorly modified the AABB class to add new funciton - SurroundingBox to calc the bounding box between two AABB boxes passed from parametaers.

2019-01-19
changed tmin to tmax in RayTracer.h
added MeshDesc.h and MeshDesc struct
worked on PLYFileReader, 20%

2019-01-20
worked on PLYFileReader, 50%

2019-01-21
added IPLYFileReaderSink;
reviewed the whole algorithm for ply file reader;
worked on PLYFileReader, 60%

2019-01-24
worked on PLYFileReader, 70%

2019-01-26
finished PLYFil,Reader, 100%
finished ResourcePool class implementation, singleton pattern, (currently supports MeshDesc Allocate/Free/Query);
added MeshTriangle.h, defined heriarchy and memebers of mesh triangle

2019-01-27
added Update interface to GeomeryObject abc
changed MetalMaterial to MirrorMaterial, DielectricMaterial to GlassMaterial
extract triangle HitTest, GetBoundingBox, ComputeNormal, ComputeArea to HitTestImpl, GetBoundingBoxImpl, ComputeNormalImpl, ComputeAreaImpl
so that we can share the codes between SimpleTriangle and MeshTriangle
finished MeshTriangle, FlatShadingMeshTriangle, SmoothShadingMeshTriangle, FlatShadingUVMeshTriangle, SmoothShadingUVMeshTriangle classes
defined all the member datas and functions for MeshObject and RegularGridMeshObject

2019-01-29
worked on RegularGridMeshObject, 30%

2019-01-30
changed SampleUponUnitShpere to SampleInUnitShpere, SampleUponUnitDisk to SampleInUnitDisk, it was cleary mistake;
added vector<TriFace>	mesh_face_datas; to MeshDesc, as well as added codes to fill it up, see the comment for details of the reason.
worked on RegularGridMeshObject, 70%

2019-01-31
worked on RegularGridMeshObject, 100%
added RTMath class
extracted AABB HitTest functions code to HitTestImpl and supported to RegularGridMeshObject
left a big problem, should I added Material * to GeomeryObject ??? otherwise, I can't set the single object's material for huge objects, like
RegularGridMeshObject, therefore, all the sub objects in it only can use the same Material *;if I use a map to record each sub object's material,
it definetly is time cosuming; 

2019-02-01
fixed the problem, referenced to the PBRT, they do the same way like I do, which is that using another wrapper class(like MaterialObject) to hold
the underlying material and geometric objects inside to keep the single geometric shape clean and light; so when generates the mesh triangle I put it to MaterialObject then it can support the SetSubObjectMaterial function to set each single material mesh triangle, and also when it gets hit, we can directly access its material via GetMaterial() function call by the object.
modified the CompoundObject HitTest logic code.
modified the check code, t < tmin + EPsilon(), prepare for the constant medium isotropic volume rendering

2019-02-02
added constant medium isot3 yet)

2019-02-03
added SampleUponUnitShpere samping method.
worked on Texture facilities, added TextureDesc.h/ImageIO.h/
In Scene.h added RenderText/RednerImage functions
modified ResourcePool, added map to hold TexutreDesc

2019-02-06
replaced all in_ray with inRay;
changed TexutreDesc to ImageTextureDesc as well as the include file name
redifend ImageTexture class;
worked on ImageTexutre class implementation, 100%, still, no testing on it yet
impl RenderText function in Scene class.
creatively introduced macro TEXTURE_STREAM_RAW to allow us to load texture stream as both RGB object or unsigned char byte RAW stream.
integrated renowed image process lib stb_master(from github), but only used stb_image.h, then supported load JPG file;
impl RenderImage function in Scene class.
added GetPixelColor interface to Texture class;
tested for both raw texture stream mode and RGB Color3f object vector mode for PNG and JPG image file, testing passed.
tested both raw texture stream mode and RGB Color object vector mode

2019-02-07
changed image texture related word pixel to texel, like GetPixelColor, GetTexelColor;

2019-02-08
modified LoadJPGFromFile, LoadPNGFromFile in Texture.cpp, it supports to directly and automatically create and allocate a texutre desc 
struct without creating and allocating it before calling the LoadXXXFromFile functions.
fixed memory bugs in Texutre.cpp, AttachXXX should check to see if it releases first.
added ImageTexutreMapping.h and class, not impl yet.
finished the architecture design and coding for Texture inverse mapping/Texture/Material
added and impl GetColor interface function in ImageTexture class;
added SetInverseMapping function in Texture class;

2019-02-09
finished ShpereicalTextureMapping;
finished XY XZ YZ regualr rectangle texture mapping (calc UV coordinate); (arbitrary rectangle is still not complete, it really needs to use the convex polygon general derivation to do that which fit to triangle and polygon, so the rectangle is natrually included)
finished TextureOnlyMaterial class (a new material class) is used to only test texture mapping

2019-02-10
fixed one bug in Volume.cpp ConstanMedium::HitTest, added the line of code: tmax = rec.t; rec.hit = true;

2019-03-02
added PlaneCheckerTexture, supported XOZ, XOY, YOZ plane procedural texture mapping, and tested on it, the image generated was amazing!;
tidy up the DemoScene in order to set up varieties of test scenes clearly and seperately
changed GetMappingTexelColor 1st paramter to HitRecord&
tested ImageTexture mapping and ShpereicalTextureMapping, rendered a shpere with the global image on it, implemented the first image based texture mapping in my life!! 

2019-03-03
debuged and tested volume rendering, unsuccessful yet (80%).
modified the code in previous NormalMaterial::Shade to adjust the current version of RayCastTracer;
added RandomTexture class to observe the volume rendering inside the boundary with different colors.

2019-03-06
found a minor error in Volume HitTest, changed if(rec2.t > tmax) to if (rec1.t > tmax) { rec2.t = tmax };

2019-03-09
changed MatteMaterial albedo from Color3f to Texture * as well as remaining the constructor and interface with Color3f as its 
parameter so that it can remain the current codes unchanged.
changed Texture interface GetMappingTextureColor to GetTextureColor to hide the inner details.
added CheckerTexture which is a common approach to render checker texture applied for both the shpere and plane and so forth.

2019-03-11
changed Sampling to SamplerBase, and designed the Sampler heirachy, and defined 4 types of samplers, RegularGrid/PureRandom/Jittered/Hammersley,
parepare to implement RTGU(phone light model/shadow/ambient occlution/area light/whitted tracer(reflective/glossy)/simple transparency/realistic transparency which involoves to in terms of fresnel reflection and transimission)
typedef Vec3<double> Point3d; since we have alread had Point2d, we can use Vec3 class to redefine Point3d;
tested Rectangle texture mapping and it turned out that the result is amzaing but it was upsidead down... need to debug it later.

2019-03-15
added SetSeed/RandInt/RandFloat functions to Random class based on CRT in stdlib.h
decided to port RTGU sampler architecture into our ray tracer.
started to port RTGU sampler codes, about 10%

2019-03-16
changed file MetaData.h to ICloneable.h
Port sampler implementation from RTGU, about 30%

2019-03-17
finished the porty of sampler implementation from RTGU, 100% (currently the code: 6000 Lines)
be about to implement RTGU phone shading model next!

2019-04-15
added BRDF.h and Material2.h;
defined BRDF base calss, prepare to implment RTGU shading.

2019-04-22
moved UpdateUVM in Camera class to PerspectiveCamera, cause no other sub classes of camera would use it;
finished BRDF base class implemntation;
finished Lambertian BRDF implemntation;

2019-04-24
finished PhongGlossySpecular BRDF class implementation;
finished BlinnPhongGlossySpecular BRDF class implementation;
 
2019-04-26
added VEC_ORIGIN AXIS_X_BIAS AXIS_Y_BIAS AXIS_Z_BIAS macros
defined Light base class according to RTGU

2019-04-27
added BLACK WHITE color3f macros;
finished AmbientLight/DirectionLight/PointLight implementations.
defined Mateial2 abstract class

2019-04-28
created a SceneLights class to hold all lights in the scene;
implemented 70% of Matte2 material class.

2019-04-29
finished Matte2 material implementation;
finished Phong material implementation;

2019-04-30
2019-05-01
changed the architecture of Phong shading material, make them all be the sub classes of PlasticMaterial, finished PlasticMaterial/PhongMaterial/BilnnPhongMaterial;
removed Material2 classes, the material all inherit from Material class, so changed the original Shade interface to PathShade, plus added the new one, Shade for RayCastTracer,
in this way, all the codes from RTGU and One weekend can be compatible very well so far.
chaned Light2.h to Light.h, the old Light.h to LightObject.h, all the lights from RTGU are implemented in Light.h;
added SceneLights objects to Scene.h and added it the the RayTracer Env parameters
modified the RayCastTracer to support the shading;
added constructor for HitRecord;

2019-05-02
;
changed Light2 to Light for all classes and their sub classes;
tested RTGU chater 14 and 15 in our own RT engine, evrything is working fine after fixed the following bugs.
fixed one important hidden bug, that is: the Vec3 class constructor didn't initialize the 3 x y z members which lead to rendering error
for glossy brdf as long as the glossy brdf's F() was calling, the L was a random value, so if ndotwi fit the condtion, then 
this case is fine, cause L will be assigned to a proper value otherwise the L is always a random and of course a wrong value.
the result is for the phong-like material on the glossy specular area, it's OK, but other areas are wrong.
fixed one important hidden bug, that is: for directional light, the direction vector must have to be normailzed after setting, not like 
point light, or the L luminace will be very large.

2019-05-06
added interface IntersectP to GeomertyObject and all its sub classes;
implemented the IntersectP interface for all related classes;
added const GeomertyObject *At(int idx) const to CompoundObjects so that the IntersectP can be defined as const member function, and
actucally it really is;
hard shadow compelet about 50%;
found a bug, the IntersecP should add the paramter of tvalue, to indicate the t value used to compare with the distance between
the hit point and the light position;

2019-05-07
2019-05-08
added WorldObjects.h to hold SceneObjects;
added CastShadow/ShadowHit interfrace to Light and implemented them in DirectionLight and PointLight;
modified Matte2Material and PlasticMaterial to support generating shadow ray and doing the shadow hit test among each objects in the scene;
built up a test scene tested all cases including two types of light and the materials, testing passed.

2019-05-11
tested BlinnPhongMaterial in PointLight;
implemented AmbientOcclusionLight, completion percentage: around 60%;

2019-05-12
added SceneObjects& sceneObjects to Light::Li interface;
completed AmbientOcclusionLight, 100%;
pass the test for it as well as the sythentic scene mixed with DirectionLight and Shadow
the sampler of multijitted, EXP is a critical parameter, it should set samll, like 1 - 10 for ambient occlustion, because the EXP is larger, the curve is shaper, so 
the direction for ambient occlusion is more likely to the same direction in a certain range so it always hit some object then it is considerated as in the shadow.
completed PerfectSepcular BRDF for ReflectiveMaterial;
fixed a careless bug in BlinnPhong BRDF, that is: Vec3d		h = (wi + wo); NOT the Vec3d		h = (-wi + wo); which leads to no high light specular upon the shpere.

2019-05-13
opitimzation Ray shadowRay(hitRec.pt, wi,/*light->GetDirection(hitRec),*/ 0.0); in Plastic and Matee material;
completed ReflectiveMaterial, about 90%, stuck in the WhittedTracer, the code structure is diffirent from the eariler tracers, it uses
steal recursive to accumlates the L value in each depth;
added RayTracer to HitRecord structure to support the implementation of WhittedTracer;
after 4 hours hard working, I finished the ReflectiveMaterial and WhittedTracer and put them together; but not test yet.
added WhittedShade for Material ABC class, the implementation of WhittedTracer is very differient from RTGU;

2019-05-15
added and defined RectangleAreaLight and DiskAreaLight classes;
added Area intereface to GeometryObject ABC class and to its all sub classes, but only implemented for Disk and Rectangle, left others to be implemented later.
reordered the functions in GeometryObject and its sub classes according to the sequence of its base class.
made a decision that is added the mArea data member in each GeometryObject classes to hold its area when in its construction or the Update being called rather than calculate it each time, and modified most of the Update functions to support this change.
implemented Emissive2Material;

2019-05-18
fixed Light Clone and Emissive2Material error, not passed parameters when constructing, so it just created a new object without the existent object's data members;
changed mLs,mLc for Emissive2Material to mKe and mCe;
created a new class EmissiveTextureMaterial to hold a texture * as the reprensentation of mCe;
defined AreaLight class architecture;

2019-05-19
fixed one crucial bug in PointLight: 
old: double dist = shadowRay.D().Distance(mLightPos);
new: double dist = shadowRay.O().Distance(mLightPos); 

fixed one crucial bug in Vec3:
old: 
inline double Distance(const Vec3& rhs) const
{	
	return this->SquareDistance(rhs);
}

new:
inline double Distance(const Vec3& rhs) const
{	
	return std::sqrt(this->SquareDistance(rhs));
}

unbelieveable !!!

it arouses one quetion: we should use Vector Point Normal to represent the different things instead o
f using the Vec3 all the time.
completed AreaLight base class;
changed the EnvironmentLight as the Light's sub class; changed EnvrionmentTextureLight as the EnvironmentLight's sub class;

2019-05-21
added SetLightShape to AreaLight;
removed mLightPos from AreaLight which can be replaced by mpLightShape object;
completed RectangleAreaLight about 80%;

2019-05-25
completed AreaLight 100%;
removed the const from Light::GetDirection(), cause the AreaLight::GetDirection need to set the mLightNormal and mWi data member;
reajusted the architecture of AreaLight, added GetNormal() and RandomSample() to the GeomertyObject ABC, implemented only for 
Rectangle and its Subclasses and Disk currently; in this way, removed previously classes RectangleAreaLight and DiskAreaLight,
changed RectangleAreaConsLight to AreaConstLight and so as Disk Area Light;
completed AreaConstLight 100%;
added TextureLambertian;
created Transform.h to add UVW and ONB class to help set up bias and translate the vector into it.

2019-05-26
added SetAutoDelete to ImageTexture;
removed const from Li function in Light class;
implemented AreaTextureProjectLight 100%;
implemented EnvironmentLight 100%;
implemented EnvironmentConstLight 100%;
implemented EnvrionmentTextureLight 100%;

2019-05-29
added MaterialBase class to support all the default implementations for Material interface class, therefore all its 
sub material classes are able to only focus on its related virtual shade*** functions;
completed AreaLightShade for all related metarial classes 100%;
completed AreaLightTracer 100%;

2019-06-02
finished PhongGlossySpecular::Sample_f_pdf and Sample_f implementation;
modified BRDF::SetSampler to detect if the mpSampler is null, otherwise it should be released before being used;
added AreaLightShade to Material ABC class, and implemented it in GlossyReflectiveMaterial;
finished GlossyReflectiveMaterial class implementation;
finally, completed AreaLightTracer, 100%, and so far I've implemented about 80% of RTGU except for the Glass and dielectrics chapters, prepare to implement SpotLight and Instance, then BART;

2019-06-04
fixed one minor bug in AmbientOcclustionLight: L = mFraction * mLs * mLs; => L = mFraction * mLs * mLc;
defined SpotLight class; not implement yet.
intended to define FastSpotLight also introduced in <<3d game programming guru>>, but can't understand the term (l dot s) in
the formula;

2019-06-05
fixed AreaLight::Li, didn't take widotn into consideration before; the light could be black if widotn is less than or equal to 0.0;
added ANG2RAD to Common.h;
completed SpotLight implementation, 100%;

2019-06-09
changed the vector<GeomertyObject *> to SceneObjects in RTEnv class;
did lots of time to debug the volumne rendering again, the interesting thing is:
I found a very serious bug:
1. Volumne::HitTest: test logic:
if (rec1.t < tmin) { rec1.t = tmin; }
if (rec2.t > tmax) { rec2.t = tmax; }
if (rec1.t > tmax) { rec2.t = tmax; }
if (rec1.t >= rec2.t) { return false; }
if (rec1.t < 0.0) { rec1.t = 0.0; }
all the fives line are necessary

2. if the ray tracer loop for finding the closest intersection among the objects like this:
if (t < tmax) {
	tmax = t;
	hitRec = hitTempRec;
	bHitAnything = true;
}
the volumne render will be the problem, because the the ray inside the volumne object, the hitRec.t is always larger than the boundary
object itself, so, the "if" will never be execuated;
so I tried to fix this like this:
if (bHit)
{
	hitRec = hitTempRec;
	bHitAnything = true;
}
the logic itself is OK, because we alread have assigned the tmax inside the HitTest procedure, so it dont' have to 
find the minimal value outside the HitTest, but due to hit test logic is diffierent between <<RTGU>> and <<OneWeekend>>,
the tmin in RTGU is used as the tmax in OneWeekend, and the tmin in OneWeekend is not existent in RTGU, because the RTGU
always use KEpsilon as the minimal value, plus, even the HitTest didn't set the tmax, it's fine, the outer will do the comparison again, which means it will use the t to compare with the tmax in the outer, and I guess in triangle HitTest, it missed the comparison for tmax, and when I wrote(copy) the HitTest code from RTGU, I missed it too.
so the outer comparison is not neccessarily, I also changed it for other RayTracers;

2019-06-16
missed the AreaLightShade in both Emissive2Material and EmissiveTextureMaterial;
fixed a critial bug, AreaConstLight::Li(), 
before was error: float ndotwi = Dot(-mWi, hitRec.pt);
and now I fixed it like this: float ndotwi = Dot(-mLightNormal, mWi);
and the same for AreaTexutreLight::Li()
tested on Area Light shading, and it's completed I tested it with my own scene and the scene in RTUG, 18.04; the result is correct.
and tested the AreaLight::ShadowHit()
double dist = Dot(oa, shadowRay.D()); 1
double dist = oa.Distance(mSamplePoint); 2
and when I use 2, the noisy is really less than 1 does. the look is better, which indicates that the two are not the same thing acually.
finally, I tried it again, it turned out that I make a mistake, acually, they are the same thing.
It should be like this: double dist = shadowRay.O().Distance(mSamplePoint); not the 2.
and I compared them again, the 2 is better, the image looks lighter and less noise

2019-06-19
set up a scene to test projective texture light, but it turned out that this kind of light is far complicated than I thought,
it failed for the testing;
so I changed AreaProjectTextureLight to AreaTextureLight;
but I found one error in AreaTextureLight::Li(), that is: the hitRec.pt is the hit point upon the object rather than the point 
upon the area light, so I can't sample the light color, so I use the mSamplePoint already sampled upon the light to get the texture color
(sample the texture) from the texture light; and the same mistake for environment light Li();
tested the texutre light, it works fine.

2019-06-20
fixed one bug which I found about 3 months ago, the image texture is upside-down when is rendering on the objects;
the reason is that when calculate the u v texture coordinates the origin for u v starts from the left-down corner of one image(you can see that from the codes in YZRect::HitTest()) while when we store the texture texels the u v starts from the left-up corner of one image,
so the ImageTexture::Sample() needs a minor change, like this:  int texel_y = (int)((1.0F - v) * (mpImgTexData->height - 1));
next goal: guess what ?? The Stanford Bunny !!!

2019-06-21
tested PLYFileReader loading from a ply format model file, it was ok;
tested RegualrGridMeshObject, found something needed to be changed. The problem was in RegularGridMeshObject::HitTest(),
when a cell which has more than one geomerty object, it should be replaced with the compound object, but this object is allocated by "new",
so the memory for compound object would never have the change to deallocate. I planned several schemes about this, finally, I did it like
this: Add a IsCompound interface to GeometryObject as well as the mnHitIdx in CompoundObject to represent which sub-object in CompoundObject is currently being hit, and use the GeomertyObject * base class to do the HitTest, when a object within the cell is hit,
calling IsCompound to see if it is a compound object, if it's true, then we use the mnHitIdx to access the sub-object in the cell and get its pMaterial object, otherwise we don't know the pMaterial because we just stored the CompoundObject to the cells rather than the MaterialObject, even if we create a new MaterialObject and store it to one of the cells, we can't get the sub-object material, because we allow the user to set each different Material to each sub-object in one cell. After doing this, a pure color model object was showed upon the screen, it's amazing, the dragon/bunny/horse all can be rendered with the material, looks like a oil paint, very art.
Next move: use the material and add some lights in the scene to render them.

2019-06-23
tested mesh triangle object, when render with material, it turned out that many things needed to be changed.
1. memory leakage occurs, that is: when a cell has more than one object, it should allocate a compound object first, so in the previous
version, it never deallocates it, because we added IsCompound interface, so when release the mesh object, we can check if it is a compound object, if it is true, we call delete to release its memory, otherwise, we don't, because the real GeometryObject stored in MeshObject base class will be responsible to do this.
2. As we can see, the compound object in mvecCells may be deleted, but the fact is that: the element in mvecCells is only a pointer which 
points to the real geometry object, so when delete its sub-objects shouldn't be deleted, so we add a member mbAutoDelete for CompoundObject class, if it is false then we don't release its sub-objects. And in this case, in MeshObject, when we set up cells, we always set it to
false, so when the MeshObject is deleted, the order is:  base class::mvecSubObjects release -> MeshObject::mvecCells released;
3. The LightObject and ShaderObject have the same bug, we added the  mbAutoDelete but we don't use it when perform the copy constructor,
if mbAutoDelete is set, we use the deep copy (Clone) otherwise we just use the shallow copy, like this:
if (mbMaterialAutoDelete)
{	
	release_material_object();
	mpMaterial = (Material *)other.mpMaterial->Clone();
}
else
{
	mpMaterial = other.mpMaterial;
}
4. The RegularGridMeshObject::HitTest only perform for the primary ray, but when a hit point send a shadow ray, it doesn't work.
So we added another function RegularGridMeshObject::IntersectP to test the hit for shadow ray.
5. This one is tricky, I spent lots of thime for debugging it.
in RegularGridMeshObject::update_mesh_normals(), when we get the normal from the geomerty object in base class's mvecObjects,
it easily gets wrong, because we created a material object before we store it, so we have to cast it to material object and
continuely call GetProxyObject() to get its real underlying geomerty object. Like this:
MaterialObject *meshTriMaterialObj = (MaterialObject *)(mvecObjects[meshDesc->mesh_vertex_faces[i][j]]);
const Vec3d face_normal = ((MeshTriangle *)meshTriMaterialObj->GetProxyObject())->GetNormal();
6. In order to reuse the mpMaterial in MaterialObject, we changed the SetMaterial to SetMaterial(Material *pMaterial, bool autoDelete = true), added autoDelete paramter, so if it set to false, one Material pointer can be shared among multiply MaterialObjects.
Like this:
PhongMaterial *pPhongMaterial = new PhongMaterial;
MaterialObject *pObj1 = new MaterialObject(pShape1, pPhongMaterial, true, false);
MaterialObject *pObj2 = new MaterialObject(pShape1, pPhongMaterial, true, false);
MaterialObject *pObj2 = new MaterialObject(pShape1, pPhongMaterial, true, true);
This trick is useful.
7. rewrote the mpProxyObject and mpMaterial management for MaterialObject, added  release_proxy_object/release_material_object/copy_constructor functions.


2019-06-24
after all these changes, I successfully tested all the scenes and models(bunny,horse,dragon) from the <<RTGU>>, it's soooooooooooo
beautiful. Amazing.
The feature: whitted tracer + phong material + directional/point light + occlusion ambient + reflective material(ground plane)
+ smooth (vertex-based normal) shading. And the rendering effect is totaly equal to <<RTGU>>.

And I've done the Mesh Traingle / Regular Grid functions test.
Next move: Fish Eye + Thin Len camera -> Spot Light + Projective Texture Spot Light -> Instance -> BART

2019-06-29
changed: Ray Camera::ShootRay(x,y,t) to bool Camera::GenerateRay(x,y,Ray&,t) in order to support FishEye camera;
so the code in Scene::RenderScene also needs to change like this:
Ray ray;
if (mpCamera->GenerateRay(x, y, ray))
{
	color += mpRayTracer->Run(ray, 0, 10);
}
implemented FishEyeCamera; 100% now we support three types of camera;

changed AmbientOcclusionLight::SetSampler(SamplerBase *sampler) to SetSampler(SamplerBase *sampler, float exp);
to reduce one line of code for calling MapSamplesToHemiShpere from the caller, which performances it inside the SetSampler now.

implemented ThinLenCamera, 100%, now we support four types of camera.

tested on SpotLight, it failed.

2019-06-30
changed CConsole to OutputConsole;
in order to easily debug, I moved g_Console from RayTraceDemoDlg.cpp to Console.h as an extern global variable.
finished test on SpotLight, it works very well, cool~~~. This type of light is not introduced in <<RTGU>>, I wrote it totaly
based on my understanding from <<3G Game Programming Guru>>, plus there is no any codes in this book which can be used as the 
reference.
during the debugging for SpotLight, I fixed several bugs, indeed. They all hanppened in Li() function.
double sdotdir = Dot(-mSurfaceDir, mLightDir); should be double sdotdir = Dot(mSurfaceDir, mLightDir);
sdotdir > 0.0 need to test to see if the dot product between the light direction and the surface direction is valid.
finished the test on ThinLenCamera, no bug.
finished the test on FishEyeCamera, found one bug, that is: after the creation of any types of camera, it should call
SetViewPlane to set the width and height for the camera, some types of camera may not need them, but FishEyeCamera really
needs it, so in the beginning, I didn't set it. No other bugs yet.
Next goal: Projective Texture Spot Light;

2019-07-09
implemented ProjectiveTextureLight, completed its definition and about 30% in total.

2019-07-10
implemented ProjectiveTextureLight, completed its definition and about 80% in total(only left Li not implemented).
fixed one bug in SpotLight::Li(), when calculate sdotdir, the mSurfaceDir should be negative, the result was right in the
former test, because the light direction was also wrong, so "two negative makes it positive", it should be like this:
double sdotdir = Dot(-mSurfaceDir, mLightDir); and the light direction in test scene should be 
pSpotLight->SetLightDirection(Vec3d(-0.5, -1, -0.75)); not (0.5, 1, 0.75)

2019-07-11
complete ProjectiveTextureLight, 100%
result is not good, still need to debug
after some debugging, the result is acceptable somehow.

2019-07-12
changed the name pProjectiveTextureLight to pProjectiveTextureSpotLight, I realized that the current implementation is based ob spot light,
later I will implement the rectangle projective texture light.

2019-07-13
completed ProjectiveTextureAreaLight, but cannot pass the test. There are many problems needed to debug.

2019-07-14
during the debugging process for ProjctiveTextureAreaLigh, fixed one critial bug in Transform.h ONB::operator[](int i),
since you want to modify its member value, you should return its reference instead of the value copy, so it should like this:
inline Vec3d& operator[](int i) { return axis[i]; }
keep debugging the ProjctiveTextureAreaLigh, the result can be acceptable, sorta, for now, compared its implementation with the one in
<<PBRT>>, it's rough. Further will work on this.

2019-07-25
reviewed codes, fixed one minor bug: ThinLenCamera::GenerateRay(), the direction vector didn't normalize

2019-10-19
fixed one bug at RegularMeshObject::HitTest(), when the mEnableAcceleration is disabled it just returned m_pAllMaterial before without considerating 
the case that each sub object can have its own material, so we need to get the target hit object according to LastHit() then access its
own material.
implemented the entire Instance/Animation architecture, including Matrix42019x4/Instance/Specific shapes which do their intersection test at the 
univeral object space, added new one Matrix.h;

2019-10-20
the calculation precision changed from double to float(considerating <<PBRT>> and <<one weekend>> both do the same) like before as well as modified all aspects related to it, and also made all the float number postfix be 'f'instead of 'F', did a overall midification.
finished the implementation for Matrix4x4 class;
finished the designation for Transform class, including the transformation creation ans functionns as well as implemented Translate and Scale transform creation functions, total about 30% of the transform/instance process. 

2019-10-21
in Common.h, it was a low-level bug, PI_OVER_180 was named to PI_UNDER_180, but the value was right, so I renamed PI_UNDER_180 to PI_OVER_180, 
besides I added PI_UNDER_180 macro for the further use
added Matrix.cpp and Transform.cpp code files to project, because the newly added funciton Inverse in Matrix4x4, also the code for 
implementation of functions Rotate and LookAt contain dozens of lines of code, inline is not suitable in this case, further more, I moved the
all tge inline functions in Transform.h to Transform.cpp
implemented Transform series functions in Transform class
implemented Apply*** series functions, thus the implementation for Transform and Matrix classes are all completed.
total about 50% of the transform/instance process. 

2019-10-23
added Instance.h/.cpp to project, and finished the designation for Instance class, not implemented yet, though.

2019-10-24
implemented Instance.cpp, about 20%
Got a issue, which is that should I delete the proxy object when the instance is released itself ? especially when the proxy object is 
a mesh object.

2019-10-25
2019-10-27
modified the Transform operator*(Transform const& rhs) the parameter from rhs to mat, which doesn't make the sence for the name rhs here.
in Instance class finally I decided to use Transform to encapulate the Forward and Inverse matrix to make our codes neat and clean, besides,
they are equally in essential implementation.
Again, modified the Transform operator*, reversed the order of matrix multiplication for Forward and Inverse, because in our render the sequence is 
different from PBRT.We are in Matrix * [point/vector/normal/ray] instead of [point/vector/normal/ray] * Matrix, the PBRT is the latter one.
added the InverseApplyRay and apply_xxx_xxx private functions for the efficient purpose.If not, In HitTest() function, we have to constructor
a Transform to hold the invMatrix and matrix in reverse oder compared to the mTransform each time, the worse case is that we have to do the 
same thing in IntersectP() function for shadow test, so it costs a lot in terms of efficiency.Now we just call InverseApplyRay to reuse the 
mTransform which is alread as the data member, then encapulated the apply*** codes to the apply_***_*** functions, these functions do the same
things according to the matrix parameter, so in InverseApplyRay for example, we just need to pass the invMatrix to the apply_ray_impl.
Modifed the Apply*** and apply_***_impl functions to be the const member functions.
Now we completed the transform/instance implementation 100%.

2019-12-05
While I was revewing the code, occasionally I found a low-level bug, which is in Instance::ComputeBoundingBox(), after the cumputation, the result
bbox object is assigned to the local variable bounding_box instead of mBoundingBox, the class data member.

2019-12-21
after having been changed the precision of double to float, I found that the DBL_MAX was still reserved, so I changed all DBL_MAX to FLT_MAX.

2020-04-17
modified the camera class, GenerateRay function, removed its third paramter, float t = 0.0, because it's generated in this function rather than
pass by outside
implemented the motion blur for moving objets, currently only support sphere object
added a new file, the MovingObject.h, and implemented the MovingShpere class.
modified the SimpleShpere class, added virtual getPos(float t) function to get the center vector so it can be used for MovingShpere sub-class to calculate its own center vector when moving. 
in RayTracer.h and Material.h, when generate a new ray, filled in the third paramter t which is just the copy of the inRay, previously it just be
set to 0.0f, cause we now attached the time information to a ray, so the secondary ray should also be set with it.
accidently noticed a bug in the NormalMaterial in Material file, it should be implemented in Emissive function instead of PathShade funciton,
cause its just a feature of self-reflectioin, cannot be applied in PathTracer.
Not tested motion blur yet.

2020-04-19
added SetExpTime for Camera, since we have mTime0 and mTime1 to represent the camera exposure time, otherwise the motin blur couldn't work.
added NormalMaterial::Shade() for RayCastTracer
tested NormalMaterial
tested motion blur for moving objects, it works fine.(not debugged yet)

2020-04-22
implemented disk texture mapping for SimpleDisk and SimpleRing geomoerty shapes in the cases of disk or ring in the XOZ/YOZ/XOY plane
added IsZero utility static function to RTMath;

2020-04-23
implemented y-axis aligned cylinder geometry referenced to RTGU chapter 19 and tested its NormalMaterial
but the opposite of the cylinder is missing, still need to debug it.

2020-04-24
fixed the cylinder render bug, now it looks good
added new cpp file, Utility.cpp, added quadratic / cubic / quaratic equation sloving functions to it.

2020-04-25
implemented SimpleCone geometric object, succeeded with just one shot
added calc_uv for calculating texture uv for cylinder and cone
implemented SimpleTorus geometric object, but it failed to render, not fix it yet.

2020-04-26
fixed the torus bug, now it can be rendered correctly.
added anotherlveCubic/SolveQuartic) to calculate quadric/cubic/quratic functions.
implemented ellipsoid geometric object;
implemented SimpleQuadratic, about 50%;
changed the way to calculate the normal of SimpleCylinder, that is if Dot(rec.n, 0.0f, which means the ray hits the inside of the 
cylinder, but the normal of cylinder is always out-faced, so it should be negative.

2020-04-27
implemented SimpleQuadratic / SimpleParaboloid / SimpleHyperboloid three new kinds of geometric objects in our ray trace.
I'm illustrated from the blog, and added mCenter to Cylinder / Cone / Torus like I did for SimpleQuadratic and so on, it's nothing special but just the initial position is a bit offsetoff the original point, and the whole process demostrates how the Instance translate in the world, which totally matches the process instroduced in RTGU.
added new H file, GeometryObjectPlus for other kind of more complex objects, such as Blob/teardrops(shape like rain)/join blend/bezier curves
/sweeping objects and such on...
implemented teardrop geometric object

2020-04-29
reviewed the entire book and cleared out the relationship among the classes in the <<Ray Tracing in One weekend>> series, the volume III, <<the rest of your life>>, tried to implement PBR based samping in our ray tracer
added PathShade2/PathShade2_pdf in Material
added ScatterRecord in HitRecord.h
added new .H file, the PDF.h and implemented its relative pdf sub-classes, like CosinePDF, LightShapePDF, MixturePDF
added RandomConsineDirection/RandomToShpere to Random class
added De_NAN to ImageProc class
added PDFValue pure virtual function to GeometricObject and implmented it for all its sub-classes, but most of them are empty for now

2020-04-30
continue to work on PBR-based sampling
the current RandomSample samples a point upon the geometry, but in PBR-based sampling we need the random direction between the random point upon
the geomerty and a relative point, and surely I can modify the current version of RandomSample to adapt to it, but in the consideration that in
some occasions we might need the random point instead of the random direction, so I decide to keep it, besides the current codes remain unchanged,
but I changed its name, the RandomSamplePoint as well as added a new one, the RandomSampleDirection
implemented PDFValue and RandomSampleDirection for rectangle and shpere geometry
implemented PathShade2/PathShade2_pdf for relative material classes
implemented PathTracer2 for PBR-based sampling
prepare to test PBR sampling using cornell box again and upload the current version of entire code to github.
debuged it, the real tricky problem is at GlassMaterial, initially, I didn't implement the PathShade2 so it derived from the base class, so it didn't do the render at all, so it should be like this:
virtual bool PathShade2(Ray const& inRay, HitRecord& hitRec, ScatterRecord& scatterRec)
{
	this->PathShade(inRay, hitRec, scatterRec.albedo, scatterRec.specular_ray);
	scatterRec.is_specular = true;

	return true;
}
call the original PathShade to do the render work, most importantly, it actually is a kind of specualr light, so set the is_specular to true and in this way PathShade2_pdf shouldn't be implemented because in the PathTracer_PBRS, if (srec.is_specular) this function will never be called.
and finally, I made it, now my ray tracer supports physically based sampling the picture looks very smooth and clean, has much less noise than it was before. (15:58)

2020-05-05
added the implicit implementation for Shpere geometry in comparsion to the geometric implementation previously, it turns out that the test hit equation eventaully are actually the same, even though the middle terms appear different.
implemented JoinBlendCylinder, about 50%

2020-05-07
forgot to assign t value to tmax in each HitTest function of the recently addedd geomertic objects and added it to each one of them
finished JoinBlendCylinder object drawing

2020-05-08
debuged on JoinBlendCylinder, and the result rendering is pretty cool.

2020-05-13
reviewed the process of solving one_6th_equation and added fparunction to solve one-6th-equation via class object, not implemented yet.

2020-05-14
implemented one_6th_equation and tested it with several equations, and it passed.
prepare to implement sweeping geometric objects.

2020-05-26 (First time work on mac os x with macbookpro)
made some change to support mac os x now, the following is the change-list:
decided to use CLion and currently I only use CLion as my IDE
edited the CMakelist.txt to include original headers and source files to this project for compiling and building.
define two macros: PLATFORM_WIN and PLATFORM_MACOSX to tell us which platform we are working on now
I used to decide to use interface to represent the abstract Render Surface, that is win and mac implement their own drawing
surface and in this way the Scene don't need change, but in order to avoid the pure virtual functions call I haven't adopted it.
so then I added two parameters to Scene::Setup and now it becomes this: virtual void Setup(int w = 400, int h = 400)
if it runs on win, nothing needs change just use the macro PLATFORM_WIN to separate win codes from mac, but if it runs on mac,
I use a new class to represent the drawing surface, the TGAImage, it's very convenient and easy to use, so in Scene::Setup, it looks like
#ifdef PLATFORM_MACOSX
		    mpSurface = new TGAImage(w, h, TGAImage::RGB);
#endif // PLATFORM_MACOSX
therefore in Scene sub-class's Setup, first of all it needs to call Scene::Setup to create drawing surface.
then the entry file is just main.cpp now, setup the callback and call the Scene build-up functions to start rendering process.
Because the clang compiler seems more strickly, I made some minor changes of code along the way, like when use FLT_MAX LFT_EPSILON
it must inclue <float.h> now, and when use std::sqrt it must include <cmath> and so on...
I tested several scenes, it works well on mac os x now.



2020-06-24 (on mac)

implemented rotational sweeping geometric object, about 25% totoally.




2020-06-25 (on mac)
finally, i completed the code for rotational sweeping geometric object, 100%, not debugged yet.
found out that GetNormal interface in GeometricObject is actually trivial, but currently it remains unchanged.
completed SolidCylinder geometric object, not debugged yet



2020-06-26 (on mac)

tested SolidCylinder, it's ok.
tested RotationalSweeping, fixed two major errors, but there is still a minor error when drawing, the overall is ok.
found one spell error, SimpleSphere2 was written as SimpleShpere2.
fixed the bug of rational sweeping, it turns out that it is due to the set-up of control points's size and camera size.
and the final result of render images are amazing.
and also i tested other geometric objects in scenes, like tori, cylinder, and three rotational sweeping wine cups with 
different materials(matte, glass wine) reflected on a mirror plane.
 

2020-06-28 (on mac)

completed tessellation sphere rendering and built up test scenes to test it with ambient occulusion light and a point light.
worked on part torus, not completed yet.
after 1 hour debuggin, it was completed.
it should like this:
if (hitPt.Z() > mCenter.Z())
{
	theta = 2.0f * PI_CONST - theta;
}

2020-06-29 (on mac)

tested part torus again, was still wrong, it turns out that in <<RTGU>> the torus building up is in local(model) coordinate
which is different from world coordinate see it in the book, and i derivated the equation several times and believed it was wrong, which may cause the error, so i referenced the torus part from libingzeng's blog, and this one is right, it is based on <<A introduction to ray tracing>>,and this time it's local coordinate is exactly as the same as the world coordinate and the equation is correct too, so the result is desirable and good.
fixed a bug which is in some geometric objects(cylinder, Teardrop...) the normal calculation is not in local coordinate that is the hit point should subtract the mCenter.
(15400)
added Matrix4x4_Mul_Matrix_4_1, Matrix1x4_Mul_Matrix_4_1 to make my codes a bit clean.
implemented tessellate rotational sweeping, 100%, and tested it, nothing to debug.
added pos parameter to tessellated sphere and rotational sweeping in order to move them in the world coordination.





2020-07-02 (on win)
added Average / Filter functions to Vec3 class.
begin to develop fresnel/dielectric material/brdf/btdf
added Fresnel to Surface class
implemented FresnelReflective brdf
added new class file, BTDF.h to handle the dielectric BSDF
implemented BTDF base class.
implemented FresnelTransmitter class.
added virtual bool WhittedShade(const Ray& inRay, HitRecord& hitRec, int& feature, Vec3f& wr, Vec3f& wt, Color3f& fr, Color3f& ft, Color3f& cf1, Color3f& cf2) to Materiar to support the dielectric material shading.(added new branch to handle the case of dielectric material)
modified WhittedTracer to support dielectric material through new brach to handle 4 cases.
total process about 80%

2020-07-03 (on win)
added IsTotalInternalReflection() function to FresnelTransmitter
added DielectricMaterial material and implemented it, completed fresnel/dielectric material 100%, not test yet.
changed WhittedShade parameter list from 3 to the rest ones, put them into a struct called WhittedRecord defined in HitRecord.h
to make the interface cleaner.
added GlobalShade to Material class to support GlobalTracer (this one is from <<RTGU>>, not the existent one from <<One weekend>>
added GlobalRecord in HitRecord.h for GlobalTracer shading context.
implemetned Emissive2Material::GlobalShade() and EmissiveTextureMaterial::GlobalShade()
implemetned BRDF::Sample_f_pdf in base class, because both the Lambertian and TextureLambertian need this.
implemetned Lambertian::Sample_f_pdf and TextureLambertian::Sample_f_pdf, in fact they just call BRDF::Sample_f_pdf()
implemented PerfectSpecular::Sample_f_pdf
implemetned Matte2Material::GlobalShade()
implemetned ReflectiveMaterial::GlobalShade()
added and implemetned the entire GlobalTracer class, this one is the currently most complicated tracer, it handles 5 cases of different
types of material, respectively, and also takes all materials into consideration, even including Glossy and Dielectric material.
optimized the global tracer by introducing path depth to reduce the noise, not test yet.
(15900)


2020-07-04 (on mac)
added new feature to part torus, previously i introduced theta to chop off torus, and now phi is introduced to open up torus.
tested it a lot, a interesting thing is when calling Light::EnableShadow(false) can avoid self-shadow, sometimes it's very helpful especially when
rendering complex geometric objects like torus, sweeping.
added mSelfShadow to MaterialBase to enable self-shadow or not.

2020-07-05 (on mac)
added mbTransformTexture and function EnableTextureTransform() to control texture transformation in Instance.
added Scale() function to Instance, because BART needs it(in its AFF definition file)
added InverseApplyPoint() and InverseApplyVector() to Transform class because TextureTransform needs it.
implemented TextureTransform class in Texture.h to support texture transformation(usually for Checker3d or Plane3d, etc)
implemented part sphere object based on original sphere object.

2020-07-06 (on mac)
fixed a long-term bug, added wpt to HitRecord structure, because this one represents the hit point in world after the instance
transformations in comparison to pt which represents the local hit point in object space. Now everything looks reasonable.
wpt is assigned in each ray tracer, after get the nearest hit point, i use the original ray to calculate the wpt in world space.
See <<RTGU>> chapter 21 for more details, and Light, Material, RayTracer modules need to use wpt, only the texture needs pt.
added EnableZoomFactor/IsZoomMode/SetZoomFactor/GetZoomFactor/mEnableZoom/mZoomFactor to Camera base class to support
camera zoom in and out, additionally, in Scene, added new branch to handle whether the camera is in zoom mode or not.
fixed two bugs, one in EnvironmentLight, wi should assign to mSamplePoint, another is in EnvrionmentTextureLight,
before: Color3f col = mLEs * mpLEc->GetTextureColor(hitRec);
now: Color3f col = mLEs * mpLEc->GetTextureColor(hitRecForSamplePoint);
is really a low-level bug.
added and implemented new Camera type, the PanoramicCamera.
changed DoInverseMapping in ImageTextureMapping to DoMapping, and modified the related codes.
added INV_TWO_PI_CONST macro to reduce division operations
added and implemented SphericalMapping
added and implemented LightProbMapping
changed SetInverseMapping in ImageTexture to SetMappingMethod and modified the related codes.

2020-07-07 (on mac)
debugged for PanoramicCamera, before, i missed "return true" in GenerateRay, but the Clang compiler has no any error prompt, now it works fine.
added SaveScene() to Scene base class instead of saving the result directly in RenderScene, because sometimes we might want only to
RenderImage, but the world objects is empty, in this case we can't output the result image, because the RenderScene just returns directly, and removed the saving codes from RenderScene at the end of the tracing.
debugged for SphericalMapping and LightProbMapping mapping, it turns out that: Scale is a very useful operation, why? because we usually set up a unit sphere, so the texture image could be very tiny, but after we scale the sphere, the texture also applies to the sphere, no need to worry about the texture size, like sky-dome, actually its just a unit sphere, and enlarge it by 1000000 times, but we can still use the normal-sized texture.
tested that stb_image lib is still good for ppm files, so i don't have to write the function to load and parse ppm files.
added template function Lerp to RTMath
added Noise.h Noise.cpp to begin to implement noise module.
added Mix to Vec3 class
added Mix/Mod/SmoothStep/SmoothPulse/SmoothPulseTrain to RTMath class
implemented noise module (totally spent 2 days)
added LatticeNoise/LinearNoise/CubicNoise/FBmTexture/WrappedFBmTexture/RampFBmTexture/WrappedTwoColors
along the implementations.(17700)
changed mpDiffuseBRDF member type in Matte2Material from Lambertian to TextureLambertian, so all matte material
only supports texture * to represent its BRDF.

2020-07-08 (on mac)
debugged for noise-based texture, wrapped/marble/sandstone, works fine.(but before LatticeNoise member mfbmMin and mfbmMax were not assigned)
due to complexity of wood noise(from RenderMan), i didn't do implement it.
added RotateX and RotateY to TextureTransform
test instance object and transform texture, succeeded in one shot, totally shocked.
debugged for Cylinder/Cone/Disk texture mapping, interestingly, the previous implementations for Cylinder and cone is wrong,
so still referenced by <<RTGU>> and now, it looks correct and cool.(but phi could be Nan, so need to check, if is Nan, set to 1e-4)
added IsNan() to RTMath class, and reviewed other places to add the check for Nan, too.
added SetSampler() function to related material classes in order to support global path
tested phong material with TextureLambetian brdf to render like a global with texture lighten up by a point light.

2020-07-09 (on mac)

continue to debugged for GlobalPath with buildup_test_caustic_scene(),
it turns out that there were two errors, one was pEmissive->SetRadiance(30.0f); was too small, like 2.0f,
just a typo when i saw RTGU code, so it caused the plane and everything in the scene were almost black,
and the other was pReflective->SetCr2(1.0, 1.0, 0.0); i wrote it as pReflective->SetKr2(1.0, 1.0, 0.0);
soooo funny, wasted almost a day to debug it. now the caustic is perfect, looks very good.
tested GlossyReflectiveMaterial, it works fine.
most importantly, all geometric objects's color should be set to BLACK before being used for GlobalPath.



2020-07-10 (on mac)

spent almost a day to debug another foolish and stupid bug which is in a very basic geometric object, the SimpleRectangle,
in its IntersectP function, it always returned true before, and also it set the tvalue to a meaningless t when actually it 
should return false, so there is no any shadow on the rectangle ground, and also the constructor is a bit difficult to 
use before, because when the rectangle is not a regular one like XY,YZ,XZ parallel rectangle, you have to set its normal
 manually, so i remove the vNormal parameter from its constructor and calculate it in its update_rectangle funciton.



2020-07-11 (on mac)

fixed a bug introduced by part sphere,
before the check: if (Dot(rec.n, inRay.D()) > 0.0f), should have the condition: if (mbPart)
and the fig 28.05 is correct now.
ReflectiveMaterial *pReflective = new ReflectiveMaterial;
pReflective->SetKa(0.3);
pReflective->SetKd(0.3);
pReflective->SetCd(Color3f(1,0,0));
pReflective->SetKs(0.2);
pReflective->SetCs2(1,1,1); // if Cs is not set, the glossy on the object will be gone.
pReflective->SetEXP(2000);
pReflective->SetKr(0.25);
pReflective->SetCr2(1.0, 1.0, 0.0); // if Cr is not set, material can be reflective.
tested dielectric(transparent) material with global tracer from RTGU, it works fine, i tested it with cornell box, 
and the caustic and its overall result is very similar to path tracer from <<one weekend>>, so it proves that the implementation
of dielectric material in global tracer is correct, besides, this part of implementation is not included in RTGU, i implemented it
according to my understanding from the book.



2020-07-12 (on mac)

introduced mPart mTheta0 mTheta1 check_in_theta_range to implement part cylinder and tested it, correct.
implemented part cone, but found a bug, i introduced check_part to solve it, see code for details.
and now both of part cylinder and cone can work fine.



2020-07-13 (on win)
tested spherical texture mapping with BilliardBall.jpg to rotate around Y-axis, found out that if you want the texutre rotating with the ball, you have to
call TextureTransform::RotateY() to rotate the same angle like the calling from Instance::RotateY()
tested global tracer with an area light and a dielectric glass sphere in cornell box, found out if ka and kd should not be set too large, because the shade or areashade 
color will be dominate instead of dielectric color.
implemented SimpleDisk::RandomSamplePoint() and SimpleDisk::RandomSamplePoint() andSimpleDisk::PDFValue() to support disk-shaped AreaLight and tested it.
modified Light::Clone() to usee *this to call default copy constructor since all data members are primitive type.
added mDistAttenu and EnableDistanceAttenuation() to PointLight to support distance attenuation effect.
i added mpViewSampler to Scene base class to support different types of sampler(Regular/PureRandom/Jittered ...) for ViewPlane to generate many many rays in one pixel,
and modified the code for getting new x, y on the view plane, but i found it is not practical, because it runs soooo slowing due to lots of calculations for just
obtaining one coordinate withing a pixel, so i still reserved the old codes even though it only uses Regular Sampler(of course you can change to other samplers manually).
tested half part sphere, found its the old bug just like part cylinder and cone, the hit point is not in range for one root doesn't mean it's not alway fit another, so 
i need to test both.Now i can render the bowl shape(see RTGU exercise 19.25)
implemented new type of FlatRimmedBowl, the result image is very nice, can't tell it from the book <<RTGU>>, almost the same.
added enum to represent component name for complex object, like solidcylinder, flatrimmedbowl, so we can set each part of material though it.
now the following change is complex:
in CompoundObject i added SetObject
in CompoundObject::HitTest() i introduced Material *material temp var to save the material for each time hit,
the greate advantage of this is: it includes the case that its sub-object is a material object, so if it has material, then it will be automatically set
to rec.pMaterial member, therefore the outer layer HitTest() doesn't need to get material accroding to mnLastHitIdx member, in fact in this way, mnLastHitIdx
is useless. so in MeshObject HitTest(), it can obtain the material from its sub-object directly.
so in FlatRimmedBowl i added SetMaterial to allow user to set material, if you dont, it just a normal geometric objct, 
so it can be used as normal geometric object or MeshObject. See DemoScene::buildup_test_geometric_object_plus() for the details.
i changed the former SolidCylinder in this way as well.

2020-07-14 (on win)
added single SetPartMaterial for SolidCylinder and FlatRimmedBowl to aovid many material setting parameters.
removed SetXXX functions form SolidCylinder and FlatRimmedBowl, becuase once the object is created, nothing happens when you call these functions.
implemented new ThickRing geometric object which is similar to the above two.
introduced interceptionH for SimpleCone to implement clipping cone in Y direction, and now it can be the part object in both H and V direction.
implemented new SolidCone and FrustumCone geometric objects. the radius of top disk need to calculate accroding to similar triangle.
implemented new ThickTrimedCone.(18841)

2020-07-15 (on win)
added SetDiffuseBRDF to Matte2Material class to allow user to replace the pre-defined diffuse brdf with their own brdf, like OrenNayar,
and the previous call from mpDiffuseBRDF need to cast to TextureLambertian, once the pre-defined mpDiffuseBRDF is replaced, the SetXXX functions cannot
be used anymore.
implemented new FixedFloatTexture and FloatTexture to support OrenNayar diffuse model( more specifically, the sigma parameter ).
set Texture 3 pure virtual functions to const function
implemented new diffuse OrenNayar BRDF type in BRDF.h
implemented new MicrofacetSpecular BRDF type in BRDF.h, and tested both, the result is fairly good.

2020-07-16 (on win)
tested microfacet brdf, checker size is related to camera setting-up
light direction vector is exactly the same as other vectors in coordinates.
compared with my microfacet brdf rendering image, looks almost as the same as the one i rendered by PBRT.(same dragon model, same light direction, 
the setting-up for test scene is same.



2020-07-18 (on mac)

added a bunch of math functions to RTMath;
added reflection.h/cpp to try to implement MicrofacetReflection from PBRT, but failed.
decided to stop implementing the brdfs in PBRT.
studied the .obj model file format, and learned its really cleaner and simpler than .ply is, start to write a .obj file loader.
changed file name IMeshFileReaderSink.h to IMeshFileReader, because now we have two types of mesh file, and i 
added new interface, IMeshFileReader, the previous PLYFileReader implements it as well as the OBJFileReader, and added one parameter for RegularGridMeshObject::LoadFromPLYFile to indicate which type to load
implemented OBJFileReader, tested on it, but there is some problem, still in debugging.
2 minutes later, i fixed it, because in obj file, 'f' (face) section index starts with 1, so i need substrate three
vertex indices by 1., and my ray tracer now supports OBJ model file.



2020-07-19 (on mac)

1. implemented a new type of material: MetalMaterial, so i can never use the cool metal material inherited from Phong shading model,
and it supports blend effect
2. tested MetalMaterial with other OBJ models, like metal ball stand, and the teapot, the result is very cool, and i almost tested
every kind of materials in my ray tracer.
fixed the bugs in PLYFileReader, before i ignored and missed the property nx ny nz normal vector section, so 
actually most PLY files i failed to parse, like PLY models from PBRT.org resource websites(the material balls),
and now i finally can render those PLY files, it turns out that it's nothing matters with the binary PLY file.
implemented new Transparent brdf and Glass2Material, because the current Dielectric material is too
slow and the result is not ideal.





2020-07-20 (on win)
1. moved platform definition macros to common.h to reduce the places to modify when change platform;
2. tested OBJ model file reader on win, its slightly different, when reverse capacity for vector, you must assign an empty value in a loop for all the slots in vector on win;
3. added Transparent brdf for MetalMaterial;

2020-07-21 (on win)
1. found SimpleSphere::IntersetP was still wrong, the logic of current version is correct
2. modified the Transparent brdf setting parameters, added another memebers to distinct mCTIn and mCTOut, and also changed it for previous GlassMaterial.
3. implemented new brdf, FresnelBlend as well as new material, SubstrateMaterial, the result is similar to pbrt.

2020-07-22 (on win)
implemented microfacet new distribution funciton GGX and Smith model, and tested with point light, the result is close to cook torrance model,
but i found a serious problem, because i almost didn't implement its pdf and light pdf, so when i change the light type, it's result is poor in comparison to
pbrt.

2020-07-23 (on win)
removed all pre-compiled macros from each file to Common.h universally
added MICROFACET_SMITH_GGX to decide if we use simth GGX model.
found a serious problem, the nested object in mesh object cannot be seen.
fixed the above bug, in  tracer, it should be like this:
if (t < tmax) {
	tmax = t;
	hitTempRec.wpt = ray.O() + hitTempRec.t * ray.D();
	hitRec = hitTempRec;
	bHitAnything = true;
}
like the initial version.
and now, my ray tracer can finally render the multiply mesh objects in composition position, like Material-test-ball from pbrt.org.
added mFactor to FresnelBlend brdf to simulate china like material
tested environment light with probe texture mapping on utha teapot, it works fine.

tested on area light cornell box again with instance boxes, 
tested varites cases, like MeshObject includes instances, and turn on acceleration or turn it off.
it turns out that i fixed the following serious bugs.
1. please compare it:
before:
Vec3f RegularGridMeshObject::find_max_bounds() {
	AABB obj_box;
	Vec3f pt_max(-FLT_MAX);
	int num_objects = (int)mvecObjects.size();

	for (int i = 0; i < num_objects; ++i) {
		mvecObjects[i]->GetBoundingBox(0.0f, 0.0f, obj_box);

		if (obj_box.mX1 > pt_max.X()) {
			pt_max[0] = obj_box.mX1;
		}
		else if (obj_box.mY1 > pt_max.Y()) {
			pt_max[1] = obj_box.mY1;
		}
		else if (obj_box.mZ1 > pt_max.Z()) {
			pt_max[2] = obj_box.mZ1;
		}
	}

	pt_max[0] += RegularGridMeshObject::KEpsilon();
	pt_max[1] += RegularGridMeshObject::KEpsilon();
	pt_max[2] += RegularGridMeshObject::KEpsilon();

	return pt_max;
}

now:
Vec3f RegularGridMeshObject::find_max_bounds() {
	AABB obj_box;
	Vec3f pt_max(-FLT_MAX);
	int num_objects = (int)mvecObjects.size();

	for (int i = 0; i < num_objects; ++i) {
		mvecObjects[i]->GetBoundingBox(0.0f, 0.0f, obj_box);

		if (obj_box.mX1 > pt_max.X()) {
			pt_max[0] = obj_box.mX1;
		}
		if (obj_box.mY1 > pt_max.Y()) {
			pt_max[1] = obj_box.mY1;
		}
		if (obj_box.mZ1 > pt_max.Z()) {
			pt_max[2] = obj_box.mZ1;
		}
	}

	pt_max[0] += RegularGridMeshObject::KEpsilon();
	pt_max[1] += RegularGridMeshObject::KEpsilon();
	pt_max[2] += RegularGridMeshObject::KEpsilon();

	return pt_max;
}
and the same as find_min_bounds()

i'd say its really a stupid low-level bug, if else if classic issue.

2.the previous SimpleRectangle HitTest implementations has slight precesion error, i reviewed the code from <<RTGU>> and 
i adpoted it including IntercetP, now the walls are normal, before it had large area of black hole.

3.the SimpleBox, when place them into Cornell box, it also had some error like rectangle, a few black lines showed up,
i reviewed the code from <<RGTU>>, the previous logic(in HitTest and IntercetP) to handle t0 and t1 was wrong, wo i 
made it right.

4. when i placed a instance into a mesh object, it was gone, i checked the code for Instance, and again it was another
low-level ridiculous misktake, please do compare:
before:
bool Instance::GetBoundingBox(float t0, float t1, AABB& bounding) {
	if (!mpProxyObject->GetBoundingBox(t0, t1, bounding)) {
		return false;
	}

	bounding = mBoundingBox;

	return true;
}

the right way is:
bool Instance::GetBoundingBox(float t0, float t1, AABB& bounding) {
//	if (!mpProxyObject->GetBoundingBox(t0, t1, bounding)) {
//		return false;
//	}

//	bounding = mBoundingBox;
	this->ComputeBoundingBox();
	bounding = mBoundingBox;

	return true;
}

only if you call ComputeBoundingBox(...) you can get bounding box of mesh object.

now if the sub-object can provide the correct bounding box for themselves, the mesh object can work fine with setting up  
regular grid.

tested this case: instance includes mesh object includes two instances and each includes a box.

but it remains one question, when mesh object turn off the Acceleration, the inner objects have no any shadows
with each other, but if the world has at least two objects, mesh object can reflect its shadow on the other object.

i mean, even if mesh object contains many sub-objects, it still counts for one object with the respect to the world object.
i guess the reason is it matters with the sequence of the sub-objects. i leave it unsolved for now.

2020-07-24 (on win)
added one constructor for ConstantTexture for convenient call
built up a scene to test inter grid object inner shadow and proved the remain issue, it's because the sequence of the inside objects,
and no need to fix, because the environment objects usually aren't be added to a grid.
completely tested on PLY OBJ, SMOOTH_SHADING, SMOOTH_UV_SHADING, and found the PLY file loader still had logic bug, 
it only assumed the sequence as x y z nx ny nz u v, before, but the issue is it may be in this order: x y z u v, no nx ny nz,
and now it supports any order,
x y z nx ny nz u v
x y z nx ny nz
x y z u v
x y z u v nx ny nz
and also tested setting up the grid object without reading from ply or obj file, instead of doing it manually,
it fills up the MeshDesc structure each member one by one, and it works fine, no bug found.
added SetDiffuseEx to FresnelBlend.

2020-07-27 (on mac)
confirmed the correctness of path tracer, and adjusted the light and wall color in cornel box scene, and now it looks
almost the same as the v3 cover;
tested mirror material and set its fuzz parameter, the result is good for metal
built up the v1 cover (random sphere scene), the result is good.
found the obj loader still has slight problem when the 'f' section is like this: f 1 2 3 not in this form: f 1/1/1 2/2/2 3/3/3,
and the comment line at the beginning, i modified the parser, it can handle both now.

2020-07-28 (on mac)
enhanced the random sphere scene to add some moving spheres.

2020-08-08 (on mac)
implemented SimpleTriangle::RandomSamplePoint() PDFValue() and RandomSampleDirection()
implemented MeshTriangle::RandomSamplePoint() PDFValue() and RandomSampleDirection() so that the PathTracer or GlobalTracer can sample from 
triangle-based light source.
implemented SimpleSphere update_sphere() to calculate mfArea in constructor, besides the previous calculation for mfArea was wrong.
added MaxAngleSampledShpere new class to handle PDFValue() and RandomSampleDirection() only for PathTracer and PathTracer_PBRS
so, re-implemented the SimpleSphere::PDFValue(), RandomSampleDirection() and RandomSamplePoint(), the way is similar to SimpleRectangle 
and SimpleTriangle, which just samples a random point on the its surface, but in MaxAngleSampledShpere it involves ONB shading coordinate.
tested cornell-box scene again with MaxAngleSampledShpere by using PathTracer_PBRS, and
it's correct.

2020-08-09 (on mac)
replaced all RandomSamplePoint with SampleRandomPoint
replaced all RandomSampleDirection with SampleRandomDirection

2020-08-15 (on mac)
implemetned CompoundObject::Area() functions.
implemented RegularGridMeshObject::Area(), RegularGridMeshObject::PDFValue() functions.
removed copy constructor and operator = from RegularGridMeshObject
added SetSeedupFactor to RegularGridMeshObject, tested and found single sphere at the center of the scene in a speed up RegularGridMeshObject
may cause holes on the sphere, but adjusted the speeding up factor can avoid it, now i consider its a bug, but use this function can temporary avoid it. 

2020-09-12 (on mac)
changed the implementation of SimpleSphere::PDFValue(), previous implementation is not correct.

2020-10-05 (on mac)
changed PathTracer_PBRS to PathTracer_MIS, after read 'multiply important sampling' from 'agraphicsguy.wordpress.com'(15 august), i realized the previous implementation for that kind of path tracer is the MIS one.
renamed ImageIO::STBILoad to STBILoadImage, i will add STBILoadHDR later, so you can easily tell between them
added STBILoadHDR to ImageIO to prepare for HDR background shading.
fixed a bug in SimpleSkyTexture::GetTextureColor, it should return BLACK directly, because when this be called a ray hits nothing in the scene, so the parameter hitRec is always useless in this case, only Sample can be used to shade.
i decided to remove SimpleSkyTexture, it now is replaced with SkylineEnv.
added SceneEnvrionment.h to implement WorldEnvironment/EmptyEnv/SkylineEnv/HDREvn which support environment shading when a ray hits nothing in scene.
added PI_HALF macro
tested it with the random sphere scene.

2020-10-06 (on mac)
built up a test scene for HDR environment test and verified the correctness in comparison to RayTracer-master, Raytracer2 from git, and the result is not bad.
modified MatteMaterial::Shade the way to calculate the outgoing direction vector, i guess both are correct, but
the reflection result is better after modifying.

2020-10-08 (on mac)
added progress bar to indicate the rendering process, previously it was only a percentage number, and now it has both.
added GammaCorrection to ImageProc
added GAMMA_CORRECTION macro to enable or disable gamma correction in result image postpone processing

2020-10-09 (on mac)
added gamma parameter to ImageProc::GammaCorrection;
added output file path to result hint

2020-10-11 (on mac)
removed GAMMA_CORRECTION, basicly, they are all HDR operators;
renamed ImageProc::GammaCorrection to HDR_Operator_Gamma1,
added HDR_Operator_Gamma2, HDR_Operator_Uncharted2Tonemap operators

2020-11-20 (on mac)
in RegularGridMeshObject::LoadFromMeshDesc, if mesh_normal is not empty then we don't need to calculate vertex normal

2020-11-25 (on mac)
added other 3 interfaces for IWindowSink, see class definition.
implemented a build-in RenderProcessReporter class to simplify the setting-up for rendering output, like progress bar/percentage info so that
each test or demo setting-up in main can directly use this class instead of the boring copy.


2022-11-23 (on mac)
the CoordinateSystem class was added to support coordinate transform in the further brdf and related material components like OrenNayar and Microfacet model.
